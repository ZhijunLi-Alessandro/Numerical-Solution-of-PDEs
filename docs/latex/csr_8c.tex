\doxysection{src/sparse/csr.c File Reference}
\hypertarget{csr_8c}{}\label{csr_8c}\index{src/sparse/csr.c@{src/sparse/csr.c}}


Implementation of sparse matrix operations in CSR format.  


{\ttfamily \#include $<$stdlib.\+h$>$}\newline
{\ttfamily \#include $<$stdio.\+h$>$}\newline
{\ttfamily \#include $<$math.\+h$>$}\newline
{\ttfamily \#include "{}csr.\+h"{}}\newline
Include dependency graph for csr.\+c\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=316pt]{csr_8c__incl}
\end{center}
\end{figure}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{structSparseCSR}{Sparse\+CSR}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{csr_8c_a4ebe4ef38d73a028ea6ed78e6dce46f2}{create\+Sparse\+CSR}} (int rows, int cols, int nnz)
\begin{DoxyCompactList}\small\item\em Create a new \doxylink{structSparseCSR}{Sparse\+CSR} matrix structure. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{csr_8c_ad76b7aa766ec949cb15bcf6ede8aadcb}{free\+Sparse\+CSR}} (\mbox{\hyperlink{structSparseCSR}{Sparse\+CSR}} \texorpdfstring{$\ast$}{*}matrix)
\begin{DoxyCompactList}\small\item\em Free the memory allocated for a \doxylink{structSparseCSR}{Sparse\+CSR} matrix. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{csr_8c_ad757786fcb200f58e1b48d771f2e5e6d}{spmv\+\_\+csr}} (const \mbox{\hyperlink{structSparseCSR}{Sparse\+CSR}} \texorpdfstring{$\ast$}{*}matrix, const double \texorpdfstring{$\ast$}{*}x, double \texorpdfstring{$\ast$}{*}y)
\begin{DoxyCompactList}\small\item\em Sparse matrix-\/vector multiplication (y = A\texorpdfstring{$\ast$}{*}x) for CSR format. \end{DoxyCompactList}\item 
\mbox{\hyperlink{structSparseCSR}{Sparse\+CSR}} \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*} \mbox{\hyperlink{csr_8c_a511084c45e428b7302a4f789f43de246}{get\+\_\+\+D\+\_\+\+L\+\_\+\+U\+\_\+csr}} (const \mbox{\hyperlink{structSparseCSR}{Sparse\+CSR}} \texorpdfstring{$\ast$}{*}matrix)
\begin{DoxyCompactList}\small\item\em Decompose a CSR matrix into diagonal, lower, and upper matrices. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{csr_8c_af089bf84e8cfa337a88a9772a4d840a0}{Jacobi\+\_\+csr\+\_\+debug}} (const \mbox{\hyperlink{structSparseCSR}{Sparse\+CSR}} \texorpdfstring{$\ast$}{*}matrix, const double \texorpdfstring{$\ast$}{*}b, double \texorpdfstring{$\ast$}{*}x, int max\+\_\+iter, double tol)
\begin{DoxyCompactList}\small\item\em Solve Ax = b using the Jacobi iterative method for CSR matrices. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{csr_8c_a7cf1992062cdbed207ef7217c4a3e20d}{Jacobi\+\_\+csr}} (const \mbox{\hyperlink{structSparseCSR}{Sparse\+CSR}} \texorpdfstring{$\ast$}{*}matrix, const double \texorpdfstring{$\ast$}{*}b, double \texorpdfstring{$\ast$}{*}x, int max\+\_\+iter, double tol)
\begin{DoxyCompactList}\small\item\em Solve Ax = b using the Jacobi iterative method for CSR matrices. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{csr_8c_a9e9cdef8c8d7069f34646f6393448e9e}{Gauss\+Seidel\+\_\+csr\+\_\+debug}} (const \mbox{\hyperlink{structSparseCSR}{Sparse\+CSR}} \texorpdfstring{$\ast$}{*}matrix, const double \texorpdfstring{$\ast$}{*}b, double \texorpdfstring{$\ast$}{*}x, int max\+\_\+iter, double tol)
\begin{DoxyCompactList}\small\item\em Solve Ax = b using the Gauss-\/\+Seidel iterative method for CSR matrices. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{csr_8c_a8e498df649d55f5935286ea1351ee89a}{Gauss\+Seidel\+\_\+csr}} (const \mbox{\hyperlink{structSparseCSR}{Sparse\+CSR}} \texorpdfstring{$\ast$}{*}matrix, const double \texorpdfstring{$\ast$}{*}b, double \texorpdfstring{$\ast$}{*}x, int max\+\_\+iter, double tol)
\begin{DoxyCompactList}\small\item\em Solve Ax = b using the Gauss-\/\+Seidel iterative method for CSR matrices. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{csr_8c_a35cd5588467e8c609ca01006634ea372}{CG\+\_\+csr\+\_\+debug}} (const \mbox{\hyperlink{structSparseCSR}{Sparse\+CSR}} \texorpdfstring{$\ast$}{*}matrix, const double \texorpdfstring{$\ast$}{*}b, double \texorpdfstring{$\ast$}{*}x, int max\+\_\+iter, double tol)
\begin{DoxyCompactList}\small\item\em Solve Ax = b using the Conjugate Gradient method for CSR matrices. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{csr_8c_a1aa4226c6ac96692cc5b691c5364b02f}{CG\+\_\+csr}} (const \mbox{\hyperlink{structSparseCSR}{Sparse\+CSR}} \texorpdfstring{$\ast$}{*}matrix, const double \texorpdfstring{$\ast$}{*}b, double \texorpdfstring{$\ast$}{*}x, int max\+\_\+iter, double tol)
\begin{DoxyCompactList}\small\item\em Solve Ax = b using the Conjugate Gradient method for CSR matrices. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Implementation of sparse matrix operations in CSR format. 

This file includes functions for creating, freeing, decomposing, matrix-\/vector multiplication, and solving linear systems using iterative methods (Jacobi, Gauss-\/\+Seidel, Conjugate Gradient) for sparse matrices stored in Compressed Sparse Row (CSR) format.

\begin{DoxyAuthor}{Author}
Li Zhijun 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
2025-\/10-\/10 
\end{DoxyDate}


\doxysubsection{Function Documentation}
\Hypertarget{csr_8c_a1aa4226c6ac96692cc5b691c5364b02f}\label{csr_8c_a1aa4226c6ac96692cc5b691c5364b02f} 
\index{csr.c@{csr.c}!CG\_csr@{CG\_csr}}
\index{CG\_csr@{CG\_csr}!csr.c@{csr.c}}
\doxysubsubsection{\texorpdfstring{CG\_csr()}{CG\_csr()}}
{\footnotesize\ttfamily void CG\+\_\+csr (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structSparseCSR}{Sparse\+CSR}} \texorpdfstring{$\ast$}{*}}]{matrix,  }\item[{const double \texorpdfstring{$\ast$}{*}}]{b,  }\item[{double \texorpdfstring{$\ast$}{*}}]{x,  }\item[{int}]{max\+\_\+iter,  }\item[{double}]{tol }\end{DoxyParamCaption})}



Solve Ax = b using the Conjugate Gradient method for CSR matrices. 


\begin{DoxyParams}{Parameters}
{\em matrix} & Pointer to the \doxylink{structSparseCSR}{Sparse\+CSR} matrix (A). \\
\hline
{\em b} & Right-\/hand side vector. \\
\hline
{\em x} & Solution vector (input\+: initial guess, output\+: result). \\
\hline
{\em max\+\_\+iter} & Maximum number of iterations. \\
\hline
{\em tol} & Tolerance for convergence. \\
\hline
\end{DoxyParams}
\Hypertarget{csr_8c_a35cd5588467e8c609ca01006634ea372}\label{csr_8c_a35cd5588467e8c609ca01006634ea372} 
\index{csr.c@{csr.c}!CG\_csr\_debug@{CG\_csr\_debug}}
\index{CG\_csr\_debug@{CG\_csr\_debug}!csr.c@{csr.c}}
\doxysubsubsection{\texorpdfstring{CG\_csr\_debug()}{CG\_csr\_debug()}}
{\footnotesize\ttfamily void CG\+\_\+csr\+\_\+debug (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structSparseCSR}{Sparse\+CSR}} \texorpdfstring{$\ast$}{*}}]{matrix,  }\item[{const double \texorpdfstring{$\ast$}{*}}]{b,  }\item[{double \texorpdfstring{$\ast$}{*}}]{x,  }\item[{int}]{max\+\_\+iter,  }\item[{double}]{tol }\end{DoxyParamCaption})}



Solve Ax = b using the Conjugate Gradient method for CSR matrices. 


\begin{DoxyParams}{Parameters}
{\em matrix} & Pointer to the \doxylink{structSparseCSR}{Sparse\+CSR} matrix (A). \\
\hline
{\em b} & Right-\/hand side vector. \\
\hline
{\em x} & Solution vector (input\+: initial guess, output\+: result). \\
\hline
{\em max\+\_\+iter} & Maximum number of iterations. \\
\hline
{\em tol} & Tolerance for convergence. \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
This function will print residuals every step. 
\end{DoxyNote}
\Hypertarget{csr_8c_a4ebe4ef38d73a028ea6ed78e6dce46f2}\label{csr_8c_a4ebe4ef38d73a028ea6ed78e6dce46f2} 
\index{csr.c@{csr.c}!createSparseCSR@{createSparseCSR}}
\index{createSparseCSR@{createSparseCSR}!csr.c@{csr.c}}
\doxysubsubsection{\texorpdfstring{createSparseCSR()}{createSparseCSR()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structSparseCSR}{Sparse\+CSR}} \texorpdfstring{$\ast$}{*} create\+Sparse\+CSR (\begin{DoxyParamCaption}\item[{int}]{rows,  }\item[{int}]{cols,  }\item[{int}]{nnz }\end{DoxyParamCaption})}



Create a new \doxylink{structSparseCSR}{Sparse\+CSR} matrix structure. 


\begin{DoxyParams}{Parameters}
{\em rows} & Number of rows. \\
\hline
{\em cols} & Number of columns. \\
\hline
{\em nnz} & Number of non-\/zero elements. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the newly allocated \doxylink{structSparseCSR}{Sparse\+CSR} structure.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The caller is responsible for freeing the allocated memory using \doxylink{csr_8h_ad76b7aa766ec949cb15bcf6ede8aadcb}{free\+Sparse\+CSR()}. 
\end{DoxyNote}
\begin{DoxySeeAlso}{See also}
\doxylink{csr_8h_ad76b7aa766ec949cb15bcf6ede8aadcb}{free\+Sparse\+CSR()} 
\end{DoxySeeAlso}
\Hypertarget{csr_8c_ad76b7aa766ec949cb15bcf6ede8aadcb}\label{csr_8c_ad76b7aa766ec949cb15bcf6ede8aadcb} 
\index{csr.c@{csr.c}!freeSparseCSR@{freeSparseCSR}}
\index{freeSparseCSR@{freeSparseCSR}!csr.c@{csr.c}}
\doxysubsubsection{\texorpdfstring{freeSparseCSR()}{freeSparseCSR()}}
{\footnotesize\ttfamily void free\+Sparse\+CSR (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structSparseCSR}{Sparse\+CSR}} \texorpdfstring{$\ast$}{*}}]{matrix }\end{DoxyParamCaption})}



Free the memory allocated for a \doxylink{structSparseCSR}{Sparse\+CSR} matrix. 


\begin{DoxyParams}{Parameters}
{\em matrix} & Pointer to the \doxylink{structSparseCSR}{Sparse\+CSR} structure to free. \\
\hline
\end{DoxyParams}
\Hypertarget{csr_8c_a8e498df649d55f5935286ea1351ee89a}\label{csr_8c_a8e498df649d55f5935286ea1351ee89a} 
\index{csr.c@{csr.c}!GaussSeidel\_csr@{GaussSeidel\_csr}}
\index{GaussSeidel\_csr@{GaussSeidel\_csr}!csr.c@{csr.c}}
\doxysubsubsection{\texorpdfstring{GaussSeidel\_csr()}{GaussSeidel\_csr()}}
{\footnotesize\ttfamily void Gauss\+Seidel\+\_\+csr (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structSparseCSR}{Sparse\+CSR}} \texorpdfstring{$\ast$}{*}}]{matrix,  }\item[{const double \texorpdfstring{$\ast$}{*}}]{b,  }\item[{double \texorpdfstring{$\ast$}{*}}]{x,  }\item[{int}]{max\+\_\+iter,  }\item[{double}]{tol }\end{DoxyParamCaption})}



Solve Ax = b using the Gauss-\/\+Seidel iterative method for CSR matrices. 


\begin{DoxyParams}{Parameters}
{\em matrix} & Pointer to the \doxylink{structSparseCSR}{Sparse\+CSR} matrix (A). \\
\hline
{\em b} & Right-\/hand side vector. \\
\hline
{\em x} & Solution vector (input\+: initial guess, output\+: result). \\
\hline
{\em max\+\_\+iter} & Maximum number of iterations. \\
\hline
{\em tol} & Tolerance for convergence. \\
\hline
\end{DoxyParams}
\Hypertarget{csr_8c_a9e9cdef8c8d7069f34646f6393448e9e}\label{csr_8c_a9e9cdef8c8d7069f34646f6393448e9e} 
\index{csr.c@{csr.c}!GaussSeidel\_csr\_debug@{GaussSeidel\_csr\_debug}}
\index{GaussSeidel\_csr\_debug@{GaussSeidel\_csr\_debug}!csr.c@{csr.c}}
\doxysubsubsection{\texorpdfstring{GaussSeidel\_csr\_debug()}{GaussSeidel\_csr\_debug()}}
{\footnotesize\ttfamily void Gauss\+Seidel\+\_\+csr\+\_\+debug (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structSparseCSR}{Sparse\+CSR}} \texorpdfstring{$\ast$}{*}}]{matrix,  }\item[{const double \texorpdfstring{$\ast$}{*}}]{b,  }\item[{double \texorpdfstring{$\ast$}{*}}]{x,  }\item[{int}]{max\+\_\+iter,  }\item[{double}]{tol }\end{DoxyParamCaption})}



Solve Ax = b using the Gauss-\/\+Seidel iterative method for CSR matrices. 


\begin{DoxyParams}{Parameters}
{\em matrix} & Pointer to the \doxylink{structSparseCSR}{Sparse\+CSR} matrix (A). \\
\hline
{\em b} & Right-\/hand side vector. \\
\hline
{\em x} & Solution vector (input\+: initial guess, output\+: result). \\
\hline
{\em max\+\_\+iter} & Maximum number of iterations. \\
\hline
{\em tol} & Tolerance for convergence. \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
This function will print residuals every step. 
\end{DoxyNote}
\Hypertarget{csr_8c_a511084c45e428b7302a4f789f43de246}\label{csr_8c_a511084c45e428b7302a4f789f43de246} 
\index{csr.c@{csr.c}!get\_D\_L\_U\_csr@{get\_D\_L\_U\_csr}}
\index{get\_D\_L\_U\_csr@{get\_D\_L\_U\_csr}!csr.c@{csr.c}}
\doxysubsubsection{\texorpdfstring{get\_D\_L\_U\_csr()}{get\_D\_L\_U\_csr()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structSparseCSR}{Sparse\+CSR}} \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*} get\+\_\+\+D\+\_\+\+L\+\_\+\+U\+\_\+csr (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structSparseCSR}{Sparse\+CSR}} \texorpdfstring{$\ast$}{*}}]{matrix }\end{DoxyParamCaption})}



Decompose a CSR matrix into diagonal, lower, and upper matrices. 

Returns an array of three \doxylink{structSparseCSR}{Sparse\+CSR} pointers\+:
\begin{DoxyItemize}
\item result\mbox{[}0\mbox{]}\+: Diagonal matrix (D)
\item result\mbox{[}1\mbox{]}\+: Lower triangular matrix (L)
\item result\mbox{[}2\mbox{]}\+: Upper triangular matrix (U)
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em matrix} & Pointer to the input \doxylink{structSparseCSR}{Sparse\+CSR} matrix. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Array of three Sparse\+CSR\texorpdfstring{$\ast$}{*} (D, L, U) 
\end{DoxyReturn}
\Hypertarget{csr_8c_a7cf1992062cdbed207ef7217c4a3e20d}\label{csr_8c_a7cf1992062cdbed207ef7217c4a3e20d} 
\index{csr.c@{csr.c}!Jacobi\_csr@{Jacobi\_csr}}
\index{Jacobi\_csr@{Jacobi\_csr}!csr.c@{csr.c}}
\doxysubsubsection{\texorpdfstring{Jacobi\_csr()}{Jacobi\_csr()}}
{\footnotesize\ttfamily void Jacobi\+\_\+csr (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structSparseCSR}{Sparse\+CSR}} \texorpdfstring{$\ast$}{*}}]{matrix,  }\item[{const double \texorpdfstring{$\ast$}{*}}]{b,  }\item[{double \texorpdfstring{$\ast$}{*}}]{x,  }\item[{int}]{max\+\_\+iter,  }\item[{double}]{tol }\end{DoxyParamCaption})}



Solve Ax = b using the Jacobi iterative method for CSR matrices. 


\begin{DoxyParams}{Parameters}
{\em matrix} & Pointer to the \doxylink{structSparseCSR}{Sparse\+CSR} matrix (A). \\
\hline
{\em b} & Right-\/hand side vector. \\
\hline
{\em x} & Solution vector (input\+: initial guess, output\+: result). \\
\hline
{\em max\+\_\+iter} & Maximum number of iterations. \\
\hline
{\em tol} & Tolerance for convergence. \\
\hline
\end{DoxyParams}
\Hypertarget{csr_8c_af089bf84e8cfa337a88a9772a4d840a0}\label{csr_8c_af089bf84e8cfa337a88a9772a4d840a0} 
\index{csr.c@{csr.c}!Jacobi\_csr\_debug@{Jacobi\_csr\_debug}}
\index{Jacobi\_csr\_debug@{Jacobi\_csr\_debug}!csr.c@{csr.c}}
\doxysubsubsection{\texorpdfstring{Jacobi\_csr\_debug()}{Jacobi\_csr\_debug()}}
{\footnotesize\ttfamily void Jacobi\+\_\+csr\+\_\+debug (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structSparseCSR}{Sparse\+CSR}} \texorpdfstring{$\ast$}{*}}]{matrix,  }\item[{const double \texorpdfstring{$\ast$}{*}}]{b,  }\item[{double \texorpdfstring{$\ast$}{*}}]{x,  }\item[{int}]{max\+\_\+iter,  }\item[{double}]{tol }\end{DoxyParamCaption})}



Solve Ax = b using the Jacobi iterative method for CSR matrices. 


\begin{DoxyParams}{Parameters}
{\em matrix} & Pointer to the \doxylink{structSparseCSR}{Sparse\+CSR} matrix (A). \\
\hline
{\em b} & Right-\/hand side vector. \\
\hline
{\em x} & Solution vector (input\+: initial guess, output\+: result). \\
\hline
{\em max\+\_\+iter} & Maximum number of iterations. \\
\hline
{\em tol} & Tolerance for convergence. \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
This function will print residuals every step. 
\end{DoxyNote}
\Hypertarget{csr_8c_ad757786fcb200f58e1b48d771f2e5e6d}\label{csr_8c_ad757786fcb200f58e1b48d771f2e5e6d} 
\index{csr.c@{csr.c}!spmv\_csr@{spmv\_csr}}
\index{spmv\_csr@{spmv\_csr}!csr.c@{csr.c}}
\doxysubsubsection{\texorpdfstring{spmv\_csr()}{spmv\_csr()}}
{\footnotesize\ttfamily void spmv\+\_\+csr (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structSparseCSR}{Sparse\+CSR}} \texorpdfstring{$\ast$}{*}}]{matrix,  }\item[{const double \texorpdfstring{$\ast$}{*}}]{x,  }\item[{double \texorpdfstring{$\ast$}{*}}]{y }\end{DoxyParamCaption})}



Sparse matrix-\/vector multiplication (y = A\texorpdfstring{$\ast$}{*}x) for CSR format. 


\begin{DoxyParams}{Parameters}
{\em matrix} & Pointer to the \doxylink{structSparseCSR}{Sparse\+CSR} matrix. \\
\hline
{\em x} & Input vector. \\
\hline
{\em y} & Output vector (result). \\
\hline
\end{DoxyParams}
